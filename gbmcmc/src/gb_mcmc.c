
/* *  Copyright (C) 2021 Tyson B. Littenberg (MSFC-ST12), Neil J. Cornish * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the GNU General Public License as published by *  the Free Software Foundation; either version 2 of the License, or *  (at your option) any later version. * *  This program is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details. * *  You should have received a copy of the GNU General Public License *  along with with program; see the file COPYING. If not, write to the *  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, *  MA  02111-1307  USA *//** @file gb_mcmc.c \brief Main function for stand-alone GBMCMC sampler *//*  REQUIRED LIBRARIES  */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <math.h>#include <time.h>#include <gsl/gsl_rng.h>#include <gsl/gsl_randist.h>#include <omp.h>#include <LISA.h>#include "GalacticBinary.h"#include "GalacticBinaryIO.h"#include "GalacticBinaryData.h"#include "GalacticBinaryPrior.h"#include "GalacticBinaryModel.h"#include "GalacticBinaryProposal.h"#include "GalacticBinaryWaveform.h"#include "GalacticBinaryMCMC.h"/** * This is the main function **/int main(int argc, char *argv[]){        time_t start, stop;    start = time(NULL);        int NMAX = 10;   //max number of frequency & time segments        /* Allocate data structures */    struct Flags *flags = malloc(sizeof(struct Flags));    struct Orbit *orbit = malloc(sizeof(struct Orbit));    struct Chain *chain = malloc(sizeof(struct Chain));    struct Data  **data = malloc(sizeof(struct Data*)*NMAX); //data[NF]            /* Parse command line and set defaults/flags */    for(int i=0; i<NMAX; i++)    {        data[i] = malloc(sizeof(struct Data));        data[i]->t0   = calloc( NMAX , sizeof(double) );        data[i]->tgap = calloc( NMAX , sizeof(double) );    }    parse(argc,argv,data,orbit,flags,chain,NMAX);    int NC = chain->NC;    int DMAX = flags->DMAX;    int mcmc_start = -flags->NBURN;        /* Allocate model structures */    struct Model **trial = malloc(sizeof(struct Model*)*NC);//trial[chain]    struct Model ***model= malloc(sizeof(struct Model**)*NC); //model[chain][source][segment]        /* Load spacecraft ephemerides */    switch(flags->orbit)    {        case 0:            initialize_analytic_orbit(orbit);            break;        case 1:            initialize_numeric_orbit(orbit);            break;        default:            fprintf(stderr,"unsupported orbit type\n");            return(1);            break;    }        /* Initialize data structures */    alloc_data(data, flags);        /* Inject strain data */    if(flags->strainData)    {        GalacticBinaryReadData(data,orbit,flags);    }    else    {        /* Inject gravitational wave signal */        if(flags->knownSource)            GalacticBinaryInjectVerificationSource(data,orbit,flags);        else            GalacticBinaryInjectSimulatedSource(data,orbit,flags);    }        /* set approximate f/fstar for segment */    for(int i=0; i<flags->NDATA; i++)        data[i]->sine_f_on_fstar = sin((data[i]->fmin + (data[i]->fmax-data[i]->fmin)/2.)/orbit->fstar);        /* Remove sources outside of window */    if(flags->catalog)        GalacticBinaryCleanEdges(data, orbit, flags);        /* Initialize data-dependent proposal */    setup_frequency_proposal(data[0]);        /* Initialize parallel chain */    if(flags->resume)        initialize_chain(chain, flags, &data[0]->cseed, "a");    else        initialize_chain(chain, flags, &data[0]->cseed, "w");        /* Initialize priors */    struct Prior *prior = malloc(sizeof(struct Prior));    if(flags->galaxyPrior) set_galaxy_prior(flags, prior);    if(flags->update) set_gmm_prior(flags, data[0], prior);        /* Initialize MCMC proposals */    struct Proposal ***proposal = malloc(NMAX*sizeof(struct Proposal**));    for(int j=0; j<NMAX; j++)    {        proposal[j] = malloc((chain->NP)*sizeof(struct Proposal*));        for(int i=0; i<chain->NP; i++) proposal[j][i] = malloc(sizeof(struct Proposal));    }    for(int j=0; j<flags->NDATA; j++) initialize_proposal(orbit, data[j], prior, chain, flags, proposal[j], DMAX);        /* Test noise model */    //test_noise_model(orbit);        /* Initialize data models */    for(int ic=0; ic<NC; ic++)    {        //printf("initialize model\n");                trial[ic] = malloc(sizeof(struct Model));        alloc_model(trial[ic],DMAX,data[0]->N,data[0]->Nchannel,data[0]->NP, data[0]->NT);                model[ic] = malloc(sizeof(struct Model *) * flags->NDATA);                //loop over frequency segments        for(int i=0; i<flags->NDATA; i++)        {            //printf("frequency segment %i\n",i);                        model[ic][i] = malloc(sizeof(struct Model));                        struct Model *model_ptr = model[ic][i];            struct Data  *data_ptr  = data[i];                        alloc_model(model_ptr,DMAX,data_ptr->N,data_ptr->Nchannel, data_ptr->NP, flags->NT);                        if(ic==0)set_uniform_prior(flags, model_ptr, data_ptr, 1);            else     set_uniform_prior(flags, model_ptr, data_ptr, 0);                        //set noise model            for(int j=0; j<flags->NT; j++) copy_noise(data_ptr->noise[j], model_ptr->noise[j]);                        //draw signal model            for(int n=0; n<DMAX; n++)            {                if(flags->cheat)                {                    struct Source *inj = data_ptr->inj;                    //map parameters to vector                    model_ptr->source[n]->NP       = inj->NP;                    model_ptr->source[n]->f0       = inj->f0;                    model_ptr->source[n]->dfdt     = inj->dfdt;                    model_ptr->source[n]->costheta = inj->costheta;                    model_ptr->source[n]->phi      = inj->phi;                    model_ptr->source[n]->amp      = inj->amp;                    model_ptr->source[n]->cosi     = inj->cosi;                    model_ptr->source[n]->phi0     = inj->phi0;                    model_ptr->source[n]->psi      = inj->psi;                    model_ptr->source[n]->d2fdt2   = inj->d2fdt2;                    map_params_to_array(model_ptr->source[n], model_ptr->source[n]->params, data_ptr->T);                                    }                else if(flags->updateCov)                {                    while ( !isfinite(draw_from_cov(data_ptr, model_ptr, model_ptr->source[n], proposal[i][8], model_ptr->source[n]->params , chain->r[ic])));                }                else if(flags->update)                {                    draw_from_gmm_prior(data_ptr, model_ptr, model_ptr->source[n], proposal[i][7], model_ptr->source[n]->params , chain->r[ic]);                }                else                {                    draw_from_uniform_prior(data_ptr, model_ptr, model_ptr->source[n], proposal[i][0], model_ptr->source[n]->params , chain->r[ic]);                }                map_array_to_params(model_ptr->source[n], model_ptr->source[n]->params, data_ptr->T);                galactic_binary_fisher(orbit, data_ptr, model_ptr->source[n], data_ptr->noise[0]);            }                        // Form master model & compute likelihood of starting position            generate_noise_model(data_ptr, model_ptr);            generate_signal_model(orbit, data_ptr, model_ptr, -1);                        //calibration error            if(flags->calibration)            {                draw_calibration_parameters(data_ptr, model_ptr, chain->r[ic]);                generate_calibration_model(data_ptr, model_ptr);                apply_calibration_model(data_ptr, model_ptr);            }            if(!flags->prior)            {                model_ptr->logL     = gaussian_log_likelihood(orbit, data_ptr, model_ptr);                model_ptr->logLnorm = gaussian_log_likelihood_constant_norm(data_ptr, model_ptr);            }            else model_ptr->logL = model_ptr->logLnorm = 0.0;                        if(ic==0) chain->logLmax += model_ptr->logL + model_ptr->logLnorm;                    }//end loop over frequency segments    }//end loop over chains        /* Start analysis from saved chain state */    if(flags->resume)    {        fprintf(stdout,"\n=============== Checkpointing ===============\n");        //check for files needed to resume        FILE *fptr = NULL;        char filename[MAXSTRINGSIZE];        int file_error = 0;                for(int ic=0; ic<chain->NC; ic++)        {            sprintf(filename,"checkpoint/chain_state_%i.dat",ic);                        if( (fptr = fopen(filename,"r")) == NULL )            {                fprintf(stderr,"Warning: Could not checkpoint run state\n");                fprintf(stderr,"         Parameter file %s does not exist\n",filename);                file_error++;                break;            }        }                //if all of the files exist resume run from checkpointed state        if(!file_error)        {            fprintf(stdout,"   Checkpoint files found. Resuming chain\n");            restore_chain_state(orbit, data, model, chain, flags, &mcmc_start);        }        fprintf(stdout,"============================================\n\n");    }        /*test proposals     FILE *test=fopen("proposal_test.dat","w");     for(int i=0; i<100000; i++)     {         double logP = draw_from_gmm_prior(data[0], model[0][0], model[0][0]->source[0], proposal[0][7], model[0][0]->source[0]->params, chain->r[0]);         print_source_params(data[0], model[0][0]->source[0], test);         fprintf(test,"%lg\n",logP);     }     fclose(test);*/    //exit(1);        //test covariance proposal    if(flags->updateCov) test_covariance_proposal(data[0], flags, model[0][0], prior, proposal[0][8], chain->r[0]);        /* Write example gb_catalog bash script in run directory */    print_gb_catalog_script(flags, data[0], orbit);    //For saving the number of threads actually given    int numThreads;    int mcmc = mcmc_start;    #pragma omp parallel num_threads(flags->threads)    {        int threadID;        //Save individual thread number        threadID = omp_get_thread_num();        //Only one thread runs this section        if(threadID==0){            numThreads = omp_get_num_threads();            printf("Running on %i thread(s).\n",numThreads);        }        #pragma omp barrier        /* The MCMC loop */        for(; mcmc < flags->NMCMC;)        {            if(threadID==0)            {                if(mcmc<0) flags->burnin=1;                else       flags->burnin=0;            }            #pragma omp barrier            // (parallel) loop over chains            for(int ic=threadID; ic<NC; ic+=numThreads)            {                            //loop over frequency segments                for(int i=0; i<flags->NDATA; i++)                {                    struct Model *model_ptr = model[chain->index[ic]][i];                    struct Model *trial_ptr = trial[chain->index[ic]];                    struct Data  *data_ptr  = data[i];                                                    for(int steps=0; steps < 100; steps++)                    {                        //for(int j=0; j<model_ptr->Nlive; j++)                        galactic_binary_mcmc(orbit, data_ptr, model_ptr, trial_ptr, chain, flags, prior, proposal[i], ic);                        if(flags->strainData || flags->simNoise)                            noise_model_mcmc(orbit, data_ptr, model_ptr, trial_ptr, chain, flags, ic);                                        }//loop over MCMC steps                    //reverse jump birth/death move                    if(flags->rj)galactic_binary_rjmcmc(orbit, data_ptr, model_ptr, trial_ptr, chain, flags, prior, proposal[i], ic);                                    //update fisher matrix for each chain                    if(mcmc%100==0)                    {                        for(int n=0; n<model_ptr->Nlive; n++)                        {                            galactic_binary_fisher(orbit, data_ptr, model_ptr->source[n], data_ptr->noise[FIXME]);                        }                    }                }//end loop over frequency segments                            //update start time for data segments                if(flags->gap) data_mcmc(orbit, data, model[chain->index[ic]], chain, flags, proposal[0], ic);                        }// end (parallel) loop over chains            //Next section is single threaded. Every thread must get here before continuing            #pragma omp barrier            if(threadID==0){                ptmcmc(model,chain,flags);                adapt_temperature_ladder(chain, mcmc+flags->NBURN);                        print_chain_files(data[FIXME], model, chain, flags, mcmc);                        //track maximum log Likelihood                if(mcmc%100)                {                    if(update_max_log_likelihood(model, chain, flags)) mcmc = -flags->NBURN;                }                        //store reconstructed waveform                if(!flags->quiet) print_waveform_draw(data, model[chain->index[0]], flags);                        //update run status                if(mcmc%data[FIXME]->downsample==0)                {                                if(!flags->quiet)                    {                        for(int i=0; i<flags->NDATA; i++)                        {                            print_chain_state(data[i], chain, model[chain->index[0]][i], flags, stdout, mcmc); //writing to file                            fprintf(stdout,"Sources: %i\n",model[chain->index[0]][i]->Nlive);                            print_acceptance_rates(proposal[i], chain->NP, 0, stdout);                        }                    }                                //save chain state to resume sampler                    save_chain_state(data, model, chain, flags, mcmc);                            }                        //dump waveforms to file, update avgLogL for thermodynamic integration                if(mcmc>0 && mcmc%data[FIXME]->downsample==0)                {                    for(int i=0; i<flags->NDATA; i++)                        save_waveforms(data[i], model[chain->index[0]][i], mcmc/data[i]->downsample);                                        for(int ic=0; ic<NC; ic++)                    {                        chain->dimension[ic][model[chain->index[ic]][0]->Nlive]++;                        for(int i=0; i<flags->NDATA; i++)                            chain->avgLogL[ic] += model[chain->index[ic]][i]->logL + model[chain->index[ic]][i]->logLnorm;                    }                }                mcmc++;            }            //Can't continue MCMC until single thread is finished            #pragma omp barrier                    }// end MCMC loop    }// End of parallelization        //print aggregate run files/results    for(int i=0; i<flags->NDATA; i++)print_waveforms_reconstruction(data[i],i);        FILE *chainFile = fopen("avg_log_likelihood.dat","w");    for(int ic=0; ic<NC; ic++) fprintf(chainFile,"%lg %lg\n",1./chain->temperature[ic],chain->avgLogL[ic]/(double)(flags->NMCMC/data[FIXME]->downsample));    fclose(chainFile);        FILE *zFile = fopen("evidence.dat","w");    for(int i=0; i<DMAX; i++) fprintf(zFile,"%i %i\n",i,chain->dimension[0][i]);    fclose(zFile);        //print total run time    stop = time(NULL);        printf(" ELAPSED TIME = %g seconds on %i thread(s)\n",(double)(stop-start),numThreads);    FILE *runlog = fopen("gb_mcmc.log","a");    fprintf(runlog," ELAPSED TIME = %g seconds on %i thread(s)\n",(double)(stop-start),numThreads);    fclose(runlog);        //free memory and exit cleanly    for(int ic=0; ic<NC; ic++)    {        for(int i=0; i<flags->NDATA; i++) free_model(model[ic][i]);        free_model(trial[ic]);    }    if(flags->orbit)free_orbit(orbit);    //free_noise(data[0]->noise[FIXME]);    //free_tdi(data[0]->tdi[FIXME]);    free_chain(chain,flags);    //free(model[FIXME][FIXME]);    //free(trial[FIXME][FIXME]);    //free(data[0]);        return 0;}